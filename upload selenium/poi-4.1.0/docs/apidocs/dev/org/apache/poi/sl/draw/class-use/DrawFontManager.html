# orm/session.py
# Copyright (C) 2005-2019 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php
"""Provides the Session class and related utilities."""


import itertools
import sys
import weakref

from . import attributes
from . import exc
from . import identity
from . import loading
from . import persistence
from . import query
from . import state as statelib
from .base import _class_to_mapper
from .base import _none_set
from .base import _state_mapper
from .base import instance_str
from .base import object_mapper
from .base import object_state
from .base import state_str
from .deprecated_interfaces import SessionExtension
from .unitofwork import UOWTransaction
from .. import engine
from .. import exc as sa_exc
from .. import sql
from .. import util
from ..inspection import inspect
from ..sql import expression
from ..sql import util as sql_util


__all__ = ["Session", "SessionTransaction", "SessionExtension", "sessionmaker"]

_sessions = weakref.WeakValueDictionary()
"""Weak-referencing dictionary of :class:`.Session` objects.
"""


def _state_session(state):
    """Given an :class:`.InstanceState`, return the :class:`.Session`
        associated, if any.
    """
    if state.session_id:
        try:
            return _sessions[state.session_id]
        except KeyError:
            pass
    return None


class _SessionClassMethods(object):
    """Class-level methods for :class:`.Session`, :class:`.sessionmaker`."""

    @classmethod
    @util.deprecated(
        "1.3",
        "The :meth:`.Session.close_all` method is deprecated and will be "
        "removed in a future release.  Please refer to "
        ":func:`.session.close_all_sessions`.",
    )
    def close_all(cls):
        """Close *all* sessions in memory."""

        close_all_sessions()

    @classmethod
    @util.dependencies("sqlalchemy.orm.util")
    def identity_key(cls, orm_util, *args, **kwargs):
        """Return an identity key.

        This is an alias of :func:`.util.identity_key`.

        """
        return orm_util.identity_key(*args, **kwargs)

    @classmethod
    def object_session(cls, instance):
        """Return the :class:`.Session` to which an object belongs.

        This is an alias of :func:`.object_session`.

        """

        return object_session(instance)


ACTIVE = util.symbol("ACTIVE")
PREPARED = util.symbol("PREPARED")
COMMITTED = util.symbol("COMMITTED")
DEACTIVE = util.symbol("DEACTIVE")
CLOSED = util.symbol("CLOSED")


class SessionTransaction(object):
    """A :class:`.Session`-level transaction.

    :class:`.SessionTransaction` is a mostly behind-the-scenes object
    not normally referenced directly by application code.   It coordinates
    among multiple :class:`.Connection` objects, maintaining a database
    transaction for each one individually, committing or rolling them
    back all at once.   It also provides optional two-phase commit behavior
    which can augment this coordination operation.

    The :attr:`.Session.transaction` attribute of :class:`.Session`
    refers to the current :class:`.SessionTransaction` object in use, if any.
    The :attr:`.SessionTransaction.parent` attribute refers to the parent
    :class:`.SessionTransaction` in the stack of :class:`.SessionTransaction`
    objects.  If this attribute is ``None``, then this is the top of the stack.
    If non-``None``, then this :class:`.SessionTransaction` refers either
    to a so-called "subtransaction" or a "nested" transaction.  A
    "subtransaction" is a scoping concept that demarcates an inner portion
    of the outermost "real" transaction.  A nested transaction, which
    is indicated when the :attr:`.SessionTransaction.nested`
    attribute is also True, indicates that this :class:`.SessionTransaction`
    corresponds to a SAVEPOINT.

    **Life Cycle**

    A :class:`.SessionTransaction` is associated with a :class:`.Session`
    in its default mode of ``autocommit=False`` immediately, associated
    with no database connections.  As the :class:`.Session` is called upon
    to emit SQL on behalf of various :class:`.Engine` or :class:`.Connection`
    objects, a corresponding :class:`.Connection` and associated
    :class:`.Transaction` is added to a collection within the
    :class:`.SessionTransaction` object, becoming one of the
    connection/transaction pairs maintained by the
    :class:`.SessionTransaction`.  The start of a :class:`.SessionTransaction`
    can be tracked using the :meth:`.SessionEvents.after_transaction_create`
    event.

    The lifespan of the :class:`.SessionTransaction` ends when the
    :meth:`.Session.commit`, :meth:`.Session.rollback` or
    :meth:`.Session.close` methods are called.  At this point, the
    :class:`.SessionTransaction` removes its association with its parent
    :class:`.Session`.   A :class:`.Session` that is in ``autocommit=False``
    mode will create a new :class:`.SessionTransaction` to replace it
    immediately, whereas a :class:`.Session` that's in ``autocommit=True``
    mode will remain without a :class:`.SessionTransaction` until the
    :meth:`.Session.begin` method is called.  The end of a
    :class:`.SessionTransaction` can be tracked using the
    :meth:`.SessionEvents.after_transaction_end` event.

    **Nesting and Subtransactions**

    Another detail of :class:`.SessionTransaction` behavior is that it is
    capable of "nesting".  This means that the :meth:`.Session.begin` method
    can be called while an existing :class:`.SessionTransaction` is already
    present, producing a new :class:`.SessionTransaction` that temporarily
    replaces the parent :class:`.SessionTransaction`.   When a
    :class:`.SessionTransaction` is produced as nested, it assigns itself to
    the :attr:`.Session.transaction` attribute, and it additionally will assign
    the previous :class:`.SessionTransaction` to its :attr:`.Session.parent`
    attribute.  The behavior is effectively a
    stack, where :attr:`.Session.transaction` refers to the current head of
    the stack, and the :attr:`.SessionTransaction.parent` attribute allows
    traversal up the stack until :attr:`.SessionTransaction.parent` is
    ``None``, indicating the top of the stack.

    When the scope of :class:`.SessionTransaction` is ended via
    :meth:`.Session.commit` or :meth:`.Session.rollback`, it restores its
    parent :class:`.SessionTransaction` back onto the
    :attr:`.Session.transaction` attribute.

    The purpose of this stack is to allow nesting of
    :meth:`.Session.rollback` or :meth:`.Session.commit` calls in context
    with various flavors of :meth:`.Session.begin`. This nesting behavior
    applies to when :meth:`.Session.begin_nested` is used to emit a
    SAVEPOINT transaction, and is also used to produce a so-called
    "subtransaction" which allows a block of code to use a
    begin/rollback/commit sequence regardless of whether or not its enclosing
    code block has begun a transaction.  The :meth:`.flush` method, whether
    called explicitly or via autoflush, is the primary consumer of the
    "subtransaction" feature, in that it wishes to guarantee that it works
    within in a transaction block regardless of whether or not the
    :class:`.Session` is in transactional mode when the method is called.

    Note that the flush process that occurs within the "autoflush" feature
    as well as when the :meth:`.Session.flush` method is used **always**
    creates a :class:`.SessionTransaction` object.   This object is normally
    a subtransaction, unless the :class:`.Session` is in autocommit mode
    and no transaction exists at all, in which cas